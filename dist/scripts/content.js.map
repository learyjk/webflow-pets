{
  "version": 3,
  "sources": ["../../src/scripts/content.ts"],
  "sourcesContent": ["import { selectors, spritesheets, AnimationTypes } from \"./enums\";\nimport { AnimationMap } from \"./types\";\n\nconst DEBUG = false;\nlet enableAnimation: boolean;\nlet interval: number;\nlet pet: Pet;\n\nchrome.storage.sync.get(\n  {\n    enableAnimation: true,\n    interval: 500,\n  },\n  function (items) {\n    enableAnimation = items.enableAnimation || true;\n    interval = items.interval || 500;\n    DEBUG && console.log({ enableAnimation, interval });\n  }\n);\n\nconst animations: AnimationMap = new Map([\n  [AnimationTypes.Blink, { frames: 2, minCycles: 1, maxCycles: 2 }],\n  [AnimationTypes.Breathe, { frames: 4, minCycles: 4, maxCycles: 8 }],\n  [AnimationTypes.Walk, { frames: 4, minCycles: 4, maxCycles: 8 }],\n  [AnimationTypes.Jump, { frames: 3, minCycles: 1, maxCycles: 1 }],\n  [AnimationTypes.Stand, { frames: 4, minCycles: 1, maxCycles: 1 }],\n  [AnimationTypes.Sleep, { frames: 2, minCycles: 20, maxCycles: 40 }],\n  [AnimationTypes.Smell, { frames: 8, minCycles: 2, maxCycles: 3 }],\n  [AnimationTypes.Eat, { frames: 4, minCycles: 2, maxCycles: 4 }],\n  [AnimationTypes.Love, { frames: 6, minCycles: 1, maxCycles: 1 }],\n]);\n\nchrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {\n  if (request.type === \"updateSettings\") {\n    DEBUG && console.log({ request });\n    interval = request.interval;\n    enableAnimation = request.enableAnimation;\n    pet && pet.reset();\n  }\n  // send response to popup script\n  sendResponse({ success: true });\n});\n\nclass Pet {\n  sprite: HTMLDivElement;\n  animations: AnimationMap;\n  positionX: number;\n  direction: 1 | -1;\n  bounds: ClientRect | DOMRect;\n  clicked: boolean;\n  animationInterval: number;\n\n  constructor(spriteSheet: string, animations: AnimationMap) {\n    this.animations = animations;\n    this.positionX = 0;\n    this.direction = 1;\n    this.clicked = false;\n\n    this.setupSprite(spriteSheet);\n    this.applyStyles();\n    this.setupEventListeners();\n  }\n\n  private setupSprite(spriteSheet: string) {\n    const topBarSpace = document.querySelectorAll<HTMLDivElement>(\n      selectors.topBarSpace\n    );\n    if (!topBarSpace[1]) return;\n\n    this.sprite = document.createElement(\"div\");\n    this.sprite.className = \"webflow-pet\";\n    topBarSpace[1].appendChild(this.sprite);\n\n    const style = document.createElement(\"style\");\n    style.textContent = `\n        .webflow-pet {\n          position: relative;\n          bottom: -4px;\n          width: 32px;\n          height: 32px;\n          background: url(${chrome.runtime.getURL(spriteSheet)});\n          background-position: 0 0;\n        }\n      `;\n    document.head.appendChild(style);\n  }\n\n  private applyStyles() {\n    if (!this.sprite.parentElement) return;\n    this.bounds = this.sprite.parentElement.getBoundingClientRect();\n    this.sprite.style.left = \"0px\"; // Reset the position of the sprite\n  }\n\n  private setupEventListeners() {\n    window.addEventListener(\"resize\", this.reset.bind(this));\n    this.sprite.addEventListener(\"click\", () => (this.clicked = true));\n  }\n\n  reset() {\n    if (!this.sprite.parentElement) return;\n    this.bounds = this.sprite.parentElement.getBoundingClientRect();\n    this.positionX = 0;\n    this.sprite.style.left = \"0px\"; // Reset the position of the sprite\n    clearInterval(this.animationInterval || 0);\n    enableAnimation && this.animate();\n  }\n\n  animate() {\n    // initial state\n    let state = AnimationTypes.Walk;\n\n    // Initialize variables to keep track of the current animation state and position\n    let animationInfo = this.animations.get(state);\n    if (!animationInfo) return;\n\n    let positionIndex = 0;\n    let positions = this.getAnimationPositions(state, animationInfo.frames);\n\n    // Initialize cycle count and target cycle count for the current animation\n    let cycleCount = 0;\n    let targetCycleCount = getRandomInt(\n      animationInfo.minCycles,\n      animationInfo.maxCycles\n    );\n\n    // Set up the animation loop using setInterval\n    this.animationInterval = setInterval(\n      () => {\n        // Log debug information\n        this.logDebugInfo(\n          state,\n          targetCycleCount,\n          cycleCount,\n          positions,\n          positionIndex\n        );\n\n        if (this.clicked) {\n          state = AnimationTypes.Love;\n          animationInfo = this.animations.get(state);\n          if (!animationInfo) return;\n\n          // Update positions and cycle count for the new animation state\n          positions = this.getAnimationPositions(state, animationInfo.frames);\n          cycleCount = 0;\n          targetCycleCount = getRandomInt(\n            animationInfo.minCycles,\n            animationInfo.maxCycles\n          );\n          this.clicked = false;\n        }\n\n        // Updates background image position for spriteshees\n        // positions[positionIndex] looks like \"32px 64px\" i.e. 2nd frame of 4th animation\n        this.displaySprite(positions[positionIndex]);\n\n        // Perform additional actions specific to the \"Walk\" animation\n        if (state === AnimationTypes.Walk) {\n          this.moveSprite(); // Move the sprite in the current direction\n          this.checkBoundaryCollision(); // Check if the sprite hits a boundary and reverse direction if needed\n          this.flipSpriteIfNeeded(); // Flip the sprite if moving left\n        }\n\n        // Advance to the next animation frame position\n        positionIndex = (positionIndex + 1) % positions.length;\n\n        // Check if the current animation cycle is complete\n        if (positionIndex === 0) {\n          cycleCount++;\n\n          // Check if the target cycle count is reached for the current animation\n          if (cycleCount >= targetCycleCount) {\n            // Move to the next state in the sequence\n\n            state = this.getNextState(state);\n            animationInfo = this.animations.get(state);\n            if (!animationInfo) return;\n\n            // Update positions and cycle count for the new animation state\n            positions = this.getAnimationPositions(state, animationInfo.frames);\n            cycleCount = 0;\n            targetCycleCount = getRandomInt(\n              animationInfo.minCycles,\n              animationInfo.maxCycles\n            );\n          }\n        }\n      },\n      interval >= 100 ? interval : 100\n    );\n  }\n\n  getNextState(currentState) {\n    if (currentState === AnimationTypes.Walk) {\n      return this.getRandomState();\n    } else if (currentState === AnimationTypes.Sleep) {\n      return AnimationTypes.Stand;\n    } else if (currentState === AnimationTypes.Stand) {\n      return AnimationTypes.Walk;\n    }\n    return Math.random() > 0.5 ? AnimationTypes.Walk : AnimationTypes.Breathe;\n  }\n\n  getRandomState() {\n    const animationKeys = Array.from(this.animations.keys());\n    const randomStateIndex = getRandomInt(0, animationKeys.length);\n    return animationKeys[randomStateIndex];\n  }\n\n  logDebugInfo(\n    state: AnimationTypes,\n    targetCycleCount: number,\n    cycleCount: number,\n    positions: string[],\n    positionIndex: number\n  ) {\n    if (DEBUG) {\n      console.log(`CURRENT ANIMATION: ${state}`);\n      console.log(`Target cycle count: ${targetCycleCount}`);\n      console.log(`Cycle count: ${cycleCount + 1}`);\n      console.log(`Number of frames: ${positions.length}`);\n      console.log(`Frame: ${positionIndex + 1}`);\n    }\n  }\n\n  displaySprite(position: string) {\n    this.sprite.style.backgroundPosition = position;\n  }\n\n  moveSprite() {\n    if (Math.random() < 0.01) {\n      this.direction *= -1;\n    }\n    this.positionX += this.direction;\n    this.sprite.style.left = `${this.positionX}px`;\n  }\n\n  checkBoundaryCollision() {\n    if (\n      this.positionX <= 0 ||\n      this.positionX >= (this.bounds?.width || 0) - 32\n    ) {\n      this.direction *= -1;\n      this.positionX += this.direction;\n    }\n  }\n\n  flipSpriteIfNeeded() {\n    this.sprite.style.transform = `scaleX(${this.direction})`;\n  }\n\n  // returns positions for background image for each frame of the animation\n  private getAnimationPositions(\n    animation: AnimationTypes,\n    frames: number,\n    reverse: boolean = false\n  ) {\n    if (frames <= 0) {\n      console.error(`Invalid number of frames: ${frames}`);\n      return [];\n    }\n    // get the index of the animation from the string name\n    const animationIndex = Array.from(this.animations.keys()).indexOf(\n      animation\n    );\n    const positions = Array.from(\n      { length: frames },\n      (_, i) => `-${i * 32}px -${animationIndex * 32}px`\n    );\n    return reverse ? positions.reverse() : positions;\n  }\n}\n\nlet loadInterval: number;\n\nloadInterval = setInterval(() => {\n  const topBarSpace = document.querySelectorAll<HTMLDivElement>(\n    selectors.topBarSpace\n  );\n  if (!topBarSpace[1]) return;\n  clearInterval(loadInterval);\n  pet = new Pet(spritesheets.babyPurpleCow, animations);\n  enableAnimation && pet.animate();\n}, 1000);\n\nfunction getRandomInt(min: number, max: number) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n"],
  "mappings": "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",
  "names": ["animations"]
}
